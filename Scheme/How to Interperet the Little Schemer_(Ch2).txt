Chapter 2:

(lat?)
list of atoms function

> (lat? l)
where l is (Jack Sprat could eat no chicken fat)
> T
b/c This S-expression is filled with individual atoms

> (lat? l)
where l is ((Jack) Sprat could eat not chicken fat)
> F
b/c (Jack) constitutes a list, not an atom which would just plainly be Jack

> (lat? l)
where l is (Jack (Sprat could) eat no chicken fat)
> F
b/c the list of atoms need to be continious and not interrupted. Like the first example.

How is (lat? ()) True?
() does not contain a list therefore, it is a primitive type or an atom? (This reflection may change....)

How does lat? function work?

(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))
> (lat? '(bacon and eggs))
*****************************************************
"Building blocks of this function lat?"
"1) use define to name a function"
"2) use lambda to create a function"
"3) use cond to ask questions compare (unfinished"
"3.5) use null? to see if l is the null list"
"3.6)If false then...but if true application ends
   "4) use atom? function from above (still not sure how it works)"
   "4.5) Use atom? to see if the first value is an atom."
   "4.6) Then a recursive call to lat? to see if the rest of the parameter is an atom followed by an atom. It goes down to null? (see 3.5) and process starts again
with a smaller list. 
"5) Which eventually ends when cdr takes out the last atom and the remaining list is () which is true for null? which ends the application
*****************************************************
Second Scenario (How do you get #F?)
where l is (bacon (and eggs))
> (lat? '(bacon (and eggs)))
@ null? it is #F so,
@ atom? car l it is bacon so it is #T
@ lat? cdr takes (and eggs) (go back to null?)
@ null? (and eggs) is is #F
@ atom? (and) this is #F (not an atom)
@ else asks if else is true (but is it?)....yes else is always true, since it is true it results in #F
Loop ends and result is #F
*******************************************************
> (or (null? l1) (atom? l2))
l1 is ()
l2 is (d e f g)
In this case both functions result in T so final result is #T

With or values if one result is T then the final result is #T
But if both are F then #F and vice versa

> (or (null? l1) (null? l2))
l1 is (a b c)
l2 is ()

First (null?) is F second (null?) is T so OR function results in a T since one is atleast T

> (or (null? l1) (null? l2))
l1 is (a b c)
l2 is (atom)

Both values are #F therefore #F

What does OR do? (Formal definition) 
(or . . . ) asks two questions, one at a time. If
the first one is true it stops and answers true.
Otherwise it asks the second question and
answers with whatever the second question
answers.

I was incorrect :(

1) In creating any function always ask the first question of null? This is the first commandment of Scheme.

Member function:

(define member?
  (lambda (a lat)
    (cond
1) ((null? lat) #f )
2)  (else (or (eq? (car lat) a) (member? a (cdr lat)))))))
Why is else the next question?
Because we do not need to ask any more questions

Is else a question?
Yes, and its value is always true

What is the meaning of 2)? 
else is always T, or keeps going while the first value is F if
it is T then it stops. But if it is F, member is called again (recursion) and the same parameter of a is put in but the paramater of lat is changed by cdr and this shorter list is evaluated. This process continues until the parameter a atom is found or the list becomes empty in which case the program ends.

Chapter 2 is finished....

